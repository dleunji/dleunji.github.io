---
Title : "백준 17825"
layout : post
date : 2021-05-04
category : Algorithm
blog : true
author : dleunji
description : 코딩 테스트 준비
---

### 17825 주사위 윷놀이

---

### Summary

- 어렵게 풀지 말고 간단히 풀 수 있다!
  - 루트를 따로 파지 말고, 시작점마다 최대 경로를 지정한다.
  - 어차피 주사위의 값은 최소 1, 최대 5이다.
- **Recursive DFS + Backtracking**
  - 종료를 알리는 리턴 조건을 상단에 놓는다.
  - continue는 신중하게 실행
  - **중복 순열**

---

https://www.acmicpc.net/problem/17825

문제를 이해하는 것은 어렵지 않았으나, 구현을 어떻게 할지 고민이 되었다. 그래서 보드 자리를 0부터 32번까지 지정하고 경우의 수에 따라 if문을 활용해서 이동 방식을 변경하려고 했다. 하지만 너무 복잡해져서 이를 배열로 모든 경우의 수를 구현하였다.

```c++
	int map[33][6] = {
    {0,1,2,3,4,5}, //0번자리
    {2,2,3,4,5,9}, //1번자리
    {4,3,4,5,9,10}, //2번자리
    {6,4,5,9,10,11}, //3번자리
    {8,5,9,10,11,12},//4번자리
    {10,6,7,8,20,29},//5번자리
    {13,7,8,20,29,30}, //6번자리
    {16,8,20,29,30,31}, //7번자리
    {19,20,29,30,31,32}, //8번자리
    {12,10,11,12,13,14}, //9번자리
    {14,11,12,13,14,15}, //10번자리
    {16,12,13,14,15,16}, //11번자리
    {18,13,14,15,16,17}, //12번자리
    {20,18,19,20,29,30}, //13번자리
    {22,15,16,17,24,25}, //14번자리
    {24,16,17,24,25,26}, //15번자리
    {26,17,24,25,26,27}, //16번자리
    {28,24,25,26,27,28}, //17번자리
    {22,19,20,29,30,31}, //18번자리
    {24,20,29,30,31,32}, //19번자리
    {25,29,30,31,32,32}, //20번자리
    {26,20,29,30,31,32}, //21번자리
    {27,21,20,29,30,31}, //22번자리
    {28,22,21,20,29,30}, //23번자리
    {30,23,22,21,20,29}, //24번자리
    {32,26,27,28,31,32}, //25번자리
    {34,27,28,31,32,32}, //26번자리
    {36,28,31,32,32,32}, //27번자리
    {38,31,32,32,32,32}, //28번자리
    {30,30,31,32,32,32}, //29번자리
    {35,31,32,32,32,32}, //30번자리
    {40,32,32,32,32,32}, //31번자리
    {0,32,32,32,32,32} //32번자리
};
```

map\[i][0] = i번째 자리의 점수

map\[i][1..5 = j] = 주사위 j로 이동한 뒤의 자리 번호

이를 바탕으로 map 위치 기반의 말 유무, 말 4개 기반의 위치를 기록한다.

```c++
int check[33] = {0,};
int piece[4] = {0,};
```

DFS 의 종료조건으로 주사위 값이 종료되면 말의 이동이 끝난다.

```c++
	//이동 종료
    if(dice >= 10) {
        maxscore = max(maxscore, score);
        return;
    }
```

그 전까지는 말은 이동하나, 어떠한 말이 이동할지는 recursive하게 중복 순열로 정한다.

```c++
	for(int i =0; i < 4; i++){
        prev = piece[i];
        next = map[prev][dices[dice]];
        if(prev == 32 || (check[next] && next!=32)){
            continue;
        }
        else {
            //해당 말 적용
            check[prev] = 0;
            check[next] = 1;
            piece[i] = next;
            move(score + map[next][0], dice+1);
            check[prev] = 1;
            check[next] = 0;
            piece[i] = prev;
        }
    }
```

for문으로 각 말에게 이동의 기회를 제공하고, 만약 이동이 끝났거나 해당 주사위의 값만큼 이동하려하지만 그 자리에 이미 다른 말이 존재한다면 이동시키지 않고 다른 말에게 기회를 넘긴다. 이 때 나는 **32번만은 예외로 이미 다른 말이 32번에 존재해도 다른 말이 32번으로 이동할 수 있도록 하는 것을 놓쳐서 푸는 데 조금 오래 걸렸다.8ㅅ8**

다음부터는 이런 실수를 줄여야지 흑흑

그래도 이제 슬슬 DFS + Backtracking 문제는 패턴을 많이 터득한 것 같아서 기쁘다^____^

